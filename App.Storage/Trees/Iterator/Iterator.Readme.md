## Данный документ предназначен для отражения мыслей не задокументированных в коде

По ходу дела всплыл вопрос - не уникальности условия поиска т.к. в текущей ее реализации predicate учитывает только значение в Node (плохо ?) `DeepFirstSearchByNodeIterator`

Не уникальность условий поиска - если будет 2 ветки где есть Node с одинаковыми значениями, то dfs всегда будет возвращать первый попавшийся
в этом я вижу проблему разростания конкретной ноды которая в dfs будет находиться раньше "таких же" Node.

```textual grap representation
0 - 1 - 2 - 3 (вот эта нода '3' всегда будет расти)
 \
   -4 - 5 - 3 (а вот эта будет "ущербной")
```

Изначально же я использовал самописный итератор с поиском где predicate учитывал "путь" прохождения - к нему и вернулся в итоге.

Как результат было решено добавить dfs с путем прохождения ('картой' куда идти когда путей несколько) `DeepFirstSearchByPathIterator`.

# Как найти все node удовлетворяющие условию поиска?

В классическом DFS (где оперируют матрицами смежности) используется доп вектор (или иная структура данных) для того что бы помечать пройденные вершины графа (дерева).
В нашем случае дерево - представленное ссылочной структурой строения, а не матрицой смежности.
Для нашего случая придется расширить `Node` для данного свойства `HasVisited`.

```post script
p.s.: Эта надстройка поможет поправить dfs таким образом что бы он искал все вхождения при необходимости.
```
